// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: active_servers.sql

package sqlc

import (
	"context"
)

const deleteActiveServerClients = `-- name: DeleteActiveServerClients :exec
DELETE FROM active_server_clients
`

func (q *Queries) DeleteActiveServerClients(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteActiveServerClientsStmt, deleteActiveServerClients)
	return err
}

const deleteActiveServers = `-- name: DeleteActiveServers :exec
DELETE FROM active_servers
`

func (q *Queries) DeleteActiveServers(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteActiveServersStmt, deleteActiveServers)
	return err
}

const existsServer = `-- name: ExistsServer :many
SELECT
	address
FROM active_servers
WHERE address = ?
LIMIT 1
`

func (q *Queries) ExistsServer(ctx context.Context, address string) ([]string, error) {
	rows, err := q.query(ctx, q.existsServerStmt, existsServer, address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var address string
		if err := rows.Scan(&address); err != nil {
			return nil, err
		}
		items = append(items, address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertActiveServerClients = `-- name: InsertActiveServerClients :exec
INSERT INTO active_server_clients (
	address,
	name,
	clan,
	country_id,
	score,
	is_player,
	team
) VALUES (?,?,?,?,?,?,?)
`

type InsertActiveServerClientsParams struct {
	Address   string
	Name      string
	Clan      string
	CountryID int64
	Score     int64
	IsPlayer  int64
	Team      *int64
}

func (q *Queries) InsertActiveServerClients(ctx context.Context, arg InsertActiveServerClientsParams) error {
	_, err := q.exec(ctx, q.insertActiveServerClientsStmt, insertActiveServerClients,
		arg.Address,
		arg.Name,
		arg.Clan,
		arg.CountryID,
		arg.Score,
		arg.IsPlayer,
		arg.Team,
	)
	return err
}

const insertActiveServers = `-- name: InsertActiveServers :exec
INSERT INTO active_servers (
	timestamp,
	address,
	protocols,
	name,
	gametype,
	passworded,
	map,
	map_sha256sum,
	map_size,
	version,
	max_clients,
	max_players,
	score_kind
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertActiveServersParams struct {
	Timestamp    int64
	Address      string
	Protocols    string
	Name         string
	Gametype     string
	Passworded   int64
	Map          string
	MapSha256sum *string
	MapSize      *int64
	Version      string
	MaxClients   int64
	MaxPlayers   int64
	ScoreKind    string
}

func (q *Queries) InsertActiveServers(ctx context.Context, arg InsertActiveServersParams) error {
	_, err := q.exec(ctx, q.insertActiveServersStmt, insertActiveServers,
		arg.Timestamp,
		arg.Address,
		arg.Protocols,
		arg.Name,
		arg.Gametype,
		arg.Passworded,
		arg.Map,
		arg.MapSha256sum,
		arg.MapSize,
		arg.Version,
		arg.MaxClients,
		arg.MaxPlayers,
		arg.ScoreKind,
	)
	return err
}

const listTrackedServerClients = `-- name: ListTrackedServerClients :many
SELECT
	c.guild_id,
	c.channel_id,
	t.message_id,
	tsc.name,
	tsc.clan,
	tsc.country_id,
	(CASE WHEN tsc.score = -9999 THEN 9223372036854775807 ELSE tsc.score END) as score,
	tsc.is_player,
	tsc.team,
	f.abbr,
	(CASE WHEN fm.emoji NOT NULL THEN fm.emoji ELSE f.emoji END) as flag_emoji
FROM channels c
JOIN tracking t ON c.channel_id = t.channel_id
JOIN active_server_clients tsc ON t.address = tsc.address
JOIN flags f ON tsc.country_id = f.flag_id
LEFT JOIN flag_mappings fm ON
	(
		t.channel_id = fm.channel_id AND
		tsc.country_id = fm.flag_id
	)
WHERE c.running = 1
ORDER BY
    c.guild_id ASC,
    c.channel_id ASC,
    t._rowid_,
    score DESC,
    tsc.name ASC
`

type ListTrackedServerClientsRow struct {
	GuildID   int64
	ChannelID int64
	MessageID int64
	Name      string
	Clan      string
	CountryID int64
	Score     interface{}
	IsPlayer  int64
	Team      *int64
	Abbr      string
	FlagEmoji interface{}
}

func (q *Queries) ListTrackedServerClients(ctx context.Context) ([]ListTrackedServerClientsRow, error) {
	rows, err := q.query(ctx, q.listTrackedServerClientsStmt, listTrackedServerClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrackedServerClientsRow{}
	for rows.Next() {
		var i ListTrackedServerClientsRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.MessageID,
			&i.Name,
			&i.Clan,
			&i.CountryID,
			&i.Score,
			&i.IsPlayer,
			&i.Team,
			&i.Abbr,
			&i.FlagEmoji,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrackedServers = `-- name: ListTrackedServers :many
SELECT
	c.guild_id,
	c.channel_id,
	t.message_id,
	ts.timestamp,
	ts.address,
	ts.protocols,
	ts.name,
	ts.gametype,
	ts.passworded,
	ts.map,
	ts.map_sha256sum,
	ts.map_size,
	ts.version,
	ts.max_clients,
	ts.max_players,
	ts.score_kind
FROM channels c
JOIN tracking t ON c.channel_id = t.channel_id
JOIN active_servers ts ON t.address = ts.address
WHERE c.running = 1
ORDER BY c.guild_id ASC, c.channel_id ASC
`

type ListTrackedServersRow struct {
	GuildID      int64
	ChannelID    int64
	MessageID    int64
	Timestamp    int64
	Address      string
	Protocols    string
	Name         string
	Gametype     string
	Passworded   int64
	Map          string
	MapSha256sum *string
	MapSize      *int64
	Version      string
	MaxClients   int64
	MaxPlayers   int64
	ScoreKind    string
}

func (q *Queries) ListTrackedServers(ctx context.Context) ([]ListTrackedServersRow, error) {
	rows, err := q.query(ctx, q.listTrackedServersStmt, listTrackedServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrackedServersRow{}
	for rows.Next() {
		var i ListTrackedServersRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.MessageID,
			&i.Timestamp,
			&i.Address,
			&i.Protocols,
			&i.Name,
			&i.Gametype,
			&i.Passworded,
			&i.Map,
			&i.MapSha256sum,
			&i.MapSize,
			&i.Version,
			&i.MaxClients,
			&i.MaxPlayers,
			&i.ScoreKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: active_servers.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const deleteActiveServerClients = `-- name: DeleteActiveServerClients :exec
DELETE FROM active_server_clients
`

func (q *Queries) DeleteActiveServerClients(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteActiveServerClientsStmt, deleteActiveServerClients)
	return err
}

const deleteActiveServers = `-- name: DeleteActiveServers :exec
DELETE FROM active_servers
`

func (q *Queries) DeleteActiveServers(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteActiveServersStmt, deleteActiveServers)
	return err
}

const existsServer = `-- name: ExistsServer :many
SELECT
	address
FROM active_servers
WHERE address = $1
LIMIT 1
`

func (q *Queries) ExistsServer(ctx context.Context, address string) ([]string, error) {
	rows, err := q.query(ctx, q.existsServerStmt, existsServer, address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var address string
		if err := rows.Scan(&address); err != nil {
			return nil, err
		}
		items = append(items, address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertActiveServerClients = `-- name: InsertActiveServerClients :exec
INSERT INTO active_server_clients (
	address,
	name,
	clan,
	country_id,
	score,
	is_player,
	team
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type InsertActiveServerClientsParams struct {
	Address   string
	Name      string
	Clan      string
	CountryID int16
	Score     int32
	IsPlayer  bool
	Team      sql.NullInt16
}

func (q *Queries) InsertActiveServerClients(ctx context.Context, arg InsertActiveServerClientsParams) error {
	_, err := q.exec(ctx, q.insertActiveServerClientsStmt, insertActiveServerClients,
		arg.Address,
		arg.Name,
		arg.Clan,
		arg.CountryID,
		arg.Score,
		arg.IsPlayer,
		arg.Team,
	)
	return err
}

const insertActiveServers = `-- name: InsertActiveServers :exec
INSERT INTO active_servers (
	timestamp,
	address,
	protocols,
	name,
	gametype,
	passworded,
	map,
	map_sha256sum,
	map_size,
	version,
	max_clients,
	max_players,
	score_kind
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type InsertActiveServersParams struct {
	Timestamp    time.Time
	Address      string
	Protocols    json.RawMessage
	Name         string
	Gametype     string
	Passworded   bool
	Map          string
	MapSha256sum sql.NullString
	MapSize      sql.NullInt32
	Version      string
	MaxClients   int16
	MaxPlayers   int16
	ScoreKind    interface{}
}

func (q *Queries) InsertActiveServers(ctx context.Context, arg InsertActiveServersParams) error {
	_, err := q.exec(ctx, q.insertActiveServersStmt, insertActiveServers,
		arg.Timestamp,
		arg.Address,
		arg.Protocols,
		arg.Name,
		arg.Gametype,
		arg.Passworded,
		arg.Map,
		arg.MapSha256sum,
		arg.MapSize,
		arg.Version,
		arg.MaxClients,
		arg.MaxPlayers,
		arg.ScoreKind,
	)
	return err
}

const listTrackedServerClients = `-- name: ListTrackedServerClients :many
SELECT
	c.guild_id,
	c.channel_id,
	t.message_id,
	tsc.name,
	tsc.clan,
	tsc.country_id,
	(CASE WHEN tsc.score = -9999 THEN 9223372036854775807 ELSE tsc.score END) as score,
	tsc.is_player,
	tsc.team,
	f.abbr,
	(CASE WHEN fm.emoji != NULL THEN fm.emoji ELSE f.emoji END) as flag_emoji
FROM channels c
JOIN tracking t ON c.channel_id = t.channel_id
JOIN active_server_clients tsc ON t.address = tsc.address
JOIN flags f ON tsc.country_id = f.flag_id
LEFT JOIN flag_mappings fm ON
	(
		t.channel_id = fm.channel_id AND
		tsc.country_id = fm.flag_id
	)
WHERE c.running = TRUE
ORDER BY
    c.guild_id ASC,
    c.channel_id ASC,
    t.id ASC,
    score DESC,
    tsc.name ASC
`

type ListTrackedServerClientsRow struct {
	GuildID   int64
	ChannelID int64
	MessageID int64
	Name      string
	Clan      string
	CountryID int16
	Score     interface{}
	IsPlayer  bool
	Team      sql.NullInt16
	Abbr      string
	FlagEmoji interface{}
}

func (q *Queries) ListTrackedServerClients(ctx context.Context) ([]ListTrackedServerClientsRow, error) {
	rows, err := q.query(ctx, q.listTrackedServerClientsStmt, listTrackedServerClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrackedServerClientsRow{}
	for rows.Next() {
		var i ListTrackedServerClientsRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.MessageID,
			&i.Name,
			&i.Clan,
			&i.CountryID,
			&i.Score,
			&i.IsPlayer,
			&i.Team,
			&i.Abbr,
			&i.FlagEmoji,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrackedServers = `-- name: ListTrackedServers :many
SELECT
	c.guild_id,
	c.channel_id,
	t.message_id,
	ts.timestamp,
	ts.address,
	ts.protocols,
	ts.name,
	ts.gametype,
	ts.passworded,
	ts.map,
	ts.map_sha256sum,
	ts.map_size,
	ts.version,
	ts.max_clients,
	ts.max_players,
	ts.score_kind
FROM channels c
JOIN tracking t ON c.channel_id = t.channel_id
JOIN active_servers ts ON t.address = ts.address
WHERE c.running = TRUE
ORDER BY c.guild_id ASC, c.channel_id ASC
`

type ListTrackedServersRow struct {
	GuildID      int64
	ChannelID    int64
	MessageID    int64
	Timestamp    time.Time
	Address      string
	Protocols    json.RawMessage
	Name         string
	Gametype     string
	Passworded   bool
	Map          string
	MapSha256sum sql.NullString
	MapSize      sql.NullInt32
	Version      string
	MaxClients   int16
	MaxPlayers   int16
	ScoreKind    interface{}
}

func (q *Queries) ListTrackedServers(ctx context.Context) ([]ListTrackedServersRow, error) {
	rows, err := q.query(ctx, q.listTrackedServersStmt, listTrackedServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrackedServersRow{}
	for rows.Next() {
		var i ListTrackedServersRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.MessageID,
			&i.Timestamp,
			&i.Address,
			&i.Protocols,
			&i.Name,
			&i.Gametype,
			&i.Passworded,
			&i.Map,
			&i.MapSha256sum,
			&i.MapSize,
			&i.Version,
			&i.MaxClients,
			&i.MaxPlayers,
			&i.ScoreKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

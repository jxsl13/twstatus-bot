// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: active_servers.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteActiveServerClients = `-- name: DeleteActiveServerClients :exec
DELETE FROM active_server_clients
`

func (q *Queries) DeleteActiveServerClients(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteActiveServerClients)
	return err
}

const deleteActiveServers = `-- name: DeleteActiveServers :exec
DELETE FROM active_servers
`

func (q *Queries) DeleteActiveServers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteActiveServers)
	return err
}

const existsServer = `-- name: ExistsServer :many
SELECT
	address
FROM active_servers
WHERE address = $1
LIMIT 1
`

func (q *Queries) ExistsServer(ctx context.Context, address string) ([]string, error) {
	rows, err := q.db.Query(ctx, existsServer, address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var address string
		if err := rows.Scan(&address); err != nil {
			return nil, err
		}
		items = append(items, address)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertActiveServerClientsParams struct {
	Address   string `db:"address"`
	Name      string `db:"name"`
	Clan      string `db:"clan"`
	CountryID int16  `db:"country_id"`
	Score     int32  `db:"score"`
	IsPlayer  bool   `db:"is_player"`
	Team      *int16 `db:"team"`
}

type InsertActiveServersParams struct {
	Timestamp    pgtype.Timestamptz `db:"timestamp"`
	Address      string             `db:"address"`
	Protocols    []byte             `db:"protocols"`
	Name         string             `db:"name"`
	Gametype     string             `db:"gametype"`
	Passworded   bool               `db:"passworded"`
	Map          string             `db:"map"`
	MapSha256sum *string            `db:"map_sha256sum"`
	MapSize      *int32             `db:"map_size"`
	Version      string             `db:"version"`
	MaxClients   int16              `db:"max_clients"`
	MaxPlayers   int16              `db:"max_players"`
	ScoreKind    string             `db:"score_kind"`
}

const listTrackedServerClients = `-- name: ListTrackedServerClients :many
SELECT
	c.guild_id,
	c.channel_id,
	t.message_id,
	tsc.name,
	tsc.clan,
	tsc.country_id,
	(CASE WHEN tsc.score = -9999 THEN 9223372036854775807 ELSE tsc.score END)::INTEGER as score,
	tsc.is_player,
	tsc.team,
	f.abbr,
	COALESCE(fm.emoji, f.emoji)::VARCHAR(64) as flag_emoji
FROM channels c
JOIN tracking t ON c.channel_id = t.channel_id
JOIN active_server_clients tsc ON t.address = tsc.address
JOIN flags f ON tsc.country_id = f.flag_id
LEFT JOIN flag_mappings fm ON
	(
		t.channel_id = fm.channel_id AND
		tsc.country_id = fm.flag_id
	)
WHERE c.running = TRUE
ORDER BY
    c.guild_id ASC,
    c.channel_id ASC,
    t.id ASC,
    score DESC,
    tsc.name ASC
`

type ListTrackedServerClientsRow struct {
	GuildID   int64  `db:"guild_id"`
	ChannelID int64  `db:"channel_id"`
	MessageID int64  `db:"message_id"`
	Name      string `db:"name"`
	Clan      string `db:"clan"`
	CountryID int16  `db:"country_id"`
	Score     int32  `db:"score"`
	IsPlayer  bool   `db:"is_player"`
	Team      *int16 `db:"team"`
	Abbr      string `db:"abbr"`
	FlagEmoji string `db:"flag_emoji"`
}

func (q *Queries) ListTrackedServerClients(ctx context.Context) ([]ListTrackedServerClientsRow, error) {
	rows, err := q.db.Query(ctx, listTrackedServerClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrackedServerClientsRow{}
	for rows.Next() {
		var i ListTrackedServerClientsRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.MessageID,
			&i.Name,
			&i.Clan,
			&i.CountryID,
			&i.Score,
			&i.IsPlayer,
			&i.Team,
			&i.Abbr,
			&i.FlagEmoji,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrackedServers = `-- name: ListTrackedServers :many
SELECT
	c.guild_id,
	c.channel_id,
	t.message_id,
	ts.timestamp,
	ts.address,
	ts.protocols,
	ts.name,
	ts.gametype,
	ts.passworded,
	ts.map,
	ts.map_sha256sum,
	ts.map_size,
	ts.version,
	ts.max_clients,
	ts.max_players,
	ts.score_kind
FROM channels c
JOIN tracking t ON c.channel_id = t.channel_id
JOIN active_servers ts ON t.address = ts.address
WHERE c.running = TRUE
ORDER BY c.guild_id ASC, c.channel_id ASC
`

type ListTrackedServersRow struct {
	GuildID      int64              `db:"guild_id"`
	ChannelID    int64              `db:"channel_id"`
	MessageID    int64              `db:"message_id"`
	Timestamp    pgtype.Timestamptz `db:"timestamp"`
	Address      string             `db:"address"`
	Protocols    []byte             `db:"protocols"`
	Name         string             `db:"name"`
	Gametype     string             `db:"gametype"`
	Passworded   bool               `db:"passworded"`
	Map          string             `db:"map"`
	MapSha256sum *string            `db:"map_sha256sum"`
	MapSize      *int32             `db:"map_size"`
	Version      string             `db:"version"`
	MaxClients   int16              `db:"max_clients"`
	MaxPlayers   int16              `db:"max_players"`
	ScoreKind    string             `db:"score_kind"`
}

func (q *Queries) ListTrackedServers(ctx context.Context) ([]ListTrackedServersRow, error) {
	rows, err := q.db.Query(ctx, listTrackedServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrackedServersRow{}
	for rows.Next() {
		var i ListTrackedServersRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.MessageID,
			&i.Timestamp,
			&i.Address,
			&i.Protocols,
			&i.Name,
			&i.Gametype,
			&i.Passworded,
			&i.Map,
			&i.MapSha256sum,
			&i.MapSize,
			&i.Version,
			&i.MaxClients,
			&i.MaxPlayers,
			&i.ScoreKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
